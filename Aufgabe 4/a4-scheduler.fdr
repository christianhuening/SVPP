nametype Id = {1..1} --Dummytask = 0
nametype Timeslots = {1..2}
nametype Task_State = {"idle", "eager", "active", "waiting"}
channel set_idle, set_waiting, set_active: Id
channel start_task
channel request, push, pop: Id.Timeslots
channel clock

my_compress(p) =
  let
    transparent normal, diamond
  within normal(diamond(p))



FIFO(<>) = push?d -> FIFO(<d>)
			
FIFO(s) = 
	pop!head(s) -> FIFO(tail(s))
	[]
	(#s<1) & push?d -> FIFO(s^<d>)



	-- if count(s) < 2 then push nach d -> Merge d,h,s


--ZustÃ¤nde der prozesse: 
	--idle(will nichts tun),
	--eager(will, ist aber nicht in wait list),
	--waiting(wartet auf scheduler),
	--active(tut etwas)

TASK(id, time, state) = (state == "idle") & start_task -> TASK(id,time,"eager")
						[]
						(state == "eager") & request!id.time -> set_waiting.id -> TASK(id,time,"waiting")
						[]
						(state == "active") & set_idle.id -> SKIP--TASK(id,time,"idle")               -- Abarbeitung des Tasks in Task oder Scheduler
						[]
						(state == "waiting") & (set_active.id -> TASK(id,time,"active"))




-- FIFO Scheduler
 

SCHED(activeTask, remainingTime, queue) =
	(request?taskId.taskTime -> set_waiting.taskId -> SCHED(activeTask,remainingTime, queue^<taskId.taskTime>))
		[]
	((remainingTime >= 1) & clock -> SCHED(activeTask, remainingTime - 1, queue)) -- Task abarbeiten
		[]
	((activeTask!=0 and remainingTime == 0 and not null(queue)) & set_idle.activeTask 
		-> let (newTask.newTime) = head(queue)
			within
		 	set_active.newTask -> SCHED(newTask,newTime, tail(queue)))
 		[]	
	((activeTask!=0 and remainingTime == 0 and null(queue)) & SCHED(0,0,<>))
		[]
	((activeTask == 0 and not null(queue)) & 
			let (newTask.newTime) = head(queue)
			within
		 	set_active.newTask -> SCHED(newTask, newTime, tail(queue)))
		
		
		        


--Timer
CLOCK = clock -> CLOCK


SYS2 =  FIFO(<1.3,2.5,3.6>) 
--START_TASK -> start_task -> STOP
TASKS = ((TASK(1,3,"idle") [|{|start_task|}|] TASK(2,5,"idle")) [|{|start_task|}|] TASK(3,6,"idle"))


SYS = (FIFO(<>) ||| CLOCK ||| TASK(1,1,"idle"))
		[|{|set_idle, set_waiting, set_active,request, clock, push, pop|}|] 
	SCHED(0,0,<>)

COMPRESSED_SYS = my_compress((CLOCK ||| TASK(1,2,"idle")))
		[|{|set_idle, set_waiting, set_active,request, clock|}|] 
	my_compress(SCHED(0,0,<>))  


SIMPLETASK = push!1.1 -> pop!1.1 -> STOP

SIMPLESYS = request.1.1 -> set_active.1 -> set_idle.1 -> STOP

--assert SIMPLETASK [T= my_compress(FIFO(<>))
--assert SIMPLETASK [T= FIFO(<>)
assert my_compress(FIFO(<>)) [T= SIMPLETASK
assert FIFO(<>) [T= SIMPLETASK

assert my_compress(SYS) [T= SIMPLESYS
assert COMPRESSED_SYS :[ deadlock free [F] ]
assert my_compress(SYS) :[ deadlock free [F] ]
assert FIFO(<>) :[ deadlock free [F] ]
assert TASK(1,1,"idle") :[ deadlock free [F] ]
assert SCHED(0,0,<>) [|{|push, pop|}|] FIFO(<>) :[ deadlock free [F] ]
--assert FIFOTEST [F= FIFO(<>)
--assert FIFO(<>) [F= FIFOTEST

